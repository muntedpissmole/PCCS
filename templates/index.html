<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Pissmole Camping Control System</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/montserrat.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/fontawesome.min.css') }}">
    <script src="{{ url_for('static', filename='js/jquery-3.6.0.min.js') }}"></script>
</head>
<body>
    <div class="container">
        <div class="scenes-panel glass">
            <div class="scenes-grid">
                {% for scene in scenes %}
                    <button class="scene-btn{% if not pca_available %} disabled{% endif %}" 
                            {% if pca_available %}onclick="activateScene('{{ scene }}')"{% endif %}>
                        <i class="fas 
                            {% if scene == 'evening' %}fa-cloud-sun
                            {% elif scene == 'night' %}fa-moon
                            {% elif scene == 'bathroom' %}fa-bath
                            {% elif scene == 'all_off' %}fa-power-off
                            {% endif %}"></i>
                        {{ scene.replace('_', ' ').title() }}
                    </button>
                {% endfor %}
            </div>
        </div>
        <div class="data-panel glass">
            <div class="data-grid">
                <div class="data-item">
                    <span><i class="fas fa-thermometer-half"></i> Temperature:</span>
                    <span id="temperature">N/A</span>
                </div>
                <div class="data-item">
                    <span><i class="fas fa-sun"></i> Sunrise:</span>
                    <span id="sunrise">---</span>
                </div>
                <div class="data-item">
                    <span><i class="fas fa-battery-full"></i> Battery Voltage:</span>
                    <span id="battery_level">N/A</span>
                </div>
                <div class="data-item">
                    <span><i class="fas fa-moon"></i> Sunset:</span>
                    <span id="sunset">---</span>
                </div>
                <div class="data-item">
                    <span><i class="fas fa-water"></i> Water Level:</span>
                    <span id="tank_level">N/A</span>
                </div>
                <div class="data-item">
                    <span><i class="fas fa-box"></i> Storage Panel:</span>
                    <span id="storage_panel">Unknown</span>
                </div>
                <div class="data-item">
                    <span><i class="fas fa-satellite"></i> GPS Fix:</span>
                    <span id="gps_fix">No</span>
                </div>
                <div class="data-item">
                    <span><i class="fas fa-inbox"></i> Rear Drawer:</span>
                    <span id="rear_drawer">Unknown</span>
                </div>				
				<div class="data-item" style="grid-column: 1 / 3;">
					<span><i class="fas fa-clock"></i> Date & Time:</span>
					<span id="current_datetime">N/A</span>
				</div>
			</div>
		</div>
        <div class="lighting-panel glass">
            <div class="lighting-slider">
                {% set pca_channels = pca9685_channels.items()|rejectattr('0', 'in', ['3', '9'])|list %}
                {% for i in range(0, pca_channels|length, 6) %}
                    <div class="lighting-page">
                        <div class="lighting-grid">
                            {% for channel, info in pca_channels[i:i+6] %}
                                <div class="control-item">
                                    <label>{{ info.name }}</label>
                                    <span class="brightness-value" id="pca-value-{{ channel }}">0%</span>
                                    <input type="range" min="0" max="100" value="0" id="pca-{{ channel }}"
                                           orient="vertical" data-channel="{{ channel }}" aria-label="Adjust brightness for {{ info.name }}">
                                    <div class="toggle-slider" onclick="toggleLight('pca9685', '{{ channel }}', this)">
                                        <div class="slider-circle"></div>
                                    </div>
                                </div>
                            {% endfor %}
                        </div>
                    </div>
                {% endfor %}
                <div class="lighting-page relay-page">
                    <div class="relay-grid">
                        {% for channel, info in relay_channels.items() %}
                            <div class="control-item">
                                <label>{{ info.name }}</label>
                                <span class="switch-state" id="relay-value-{{ channel }}">Off</span>
                                <div class="toggle-slider" onclick="toggleRelay('relays', '{{ channel }}', this)">
                                    <div class="slider-circle"></div>
                                </div>
                            </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
            <div class="pagination-dots">
                {% set page_count = (pca_channels|length / 6)|round(0, 'ceil')|int %}
                {% for i in range(page_count + 1) %}
                    <span class="dot" data-page="{{ i }}"></span>
                {% endfor %}
            </div>
            <i class="fas fa-sync-alt refresh-icon" onclick="refreshPage()"></i>
            <i class="fas fa-gear gear-icon" onclick="openSettings()"></i>
        </div>
    </div>
    <div class="settings-modal" id="settingsModal">
        <span class="close-settings" onclick="closeSettings(event)"><i class="fas fa-times"></i></span>
        <div class="settings-content">
            <div class="settings-tabs">
                <button class="tab-btn active" onclick="openTab('general')">General</button>
                <button class="tab-btn" onclick="openTab('scene-editor')">Scene Editor</button>
                <button class="tab-btn" onclick="openTab('event-scheduler')">Event Scheduler</button>
                <button class="tab-btn" onclick="openTab('help')">Help</button>
            </div>
            <div id="general-tab" class="tab-content active">
                <h2>General Settings</h2>
                <!-- Top left: Dark Mode -->
                <div class="setting-item">
                    <span>Dark Mode:</span>
                    <label class="settings-toggle" for="dark-mode-toggle">
                        <input type="checkbox" id="dark-mode-toggle" class="toggle-input">
                        <span class="slider-circle"></span>
                    </label>
                </div>
                <!-- Top right: Screen Brightness -->
					<div class="setting-item brightness-setting">
						<span>Screen Brightness:</span>
						<div class="brightness-buttons">
							<button class="brightness-btn" data-brightness="low" aria-label="Set screen brightness to Low">Low</button>
							<button class="brightness-btn active" data-brightness="medium" aria-label="Set screen brightness to Medium">Medium</button>
							<button class="brightness-btn" data-brightness="high" aria-label="Set screen brightness to High">High</button>
						</div>
					</div>
                <!-- Middle left: Auto Theme Switch -->
                <div class="setting-item">
                    <span>Auto Theme Switch:</span>
                    <label class="settings-toggle" for="auto-theme-toggle">
                        <input type="checkbox" id="auto-theme-toggle" class="toggle-input">
                        <span class="slider-circle"></span>
                    </label>
                </div>
                <!-- Middle right: Shutdown -->
                <div class="setting-item shutdown-container">
                    <button class="shutdown-btn" onclick="initiateShutdown()">Shutdown System</button>
                </div>
                <!-- Bottom left: Default Theme -->
                <div class="setting-item">
                    <span>Default Theme:</span>
                    <select id="default-theme" disabled>
                        <option value="light">Light</option>
                        <option value="dark">Dark</option>
                    </select>
                </div>
            </div>
            <div id="scene-editor-tab" class="tab-content">
                <h2>Scene Editor</h2>
                <p>(Coming Soon)</p>
            </div>
            <div id="event-scheduler-tab" class="tab-content">
                <h2>Event Scheduler</h2>
                <p>(Coming Soon)</p>
            </div>
			<div id="help-tab" class="tab-content">
				<h2>Help</h2>
				<div class="setting-item">
					<span>GPS Coordinates:</span>
					<span class="setting-value" id="gps-coordinates">N/A</span>
				</div>
				<div class="setting-item">
					<span>Software Version:</span>
					<span class="setting-value">1.4.0-beta 1</span>
				</div>
				<div class="setting-item">
					<span>GitHub:</span>
					<div class="github-link">github.com/muntedpissmole/pccs</div>
				</div>
			</div>
        </div>
    </div>

<script>
function springEase(t) {
    // Spring-like easing: combines exponential decay and oscillation
    return 1 - Math.cos(t * 4 * Math.PI) * Math.exp(-6 * t);
}
$(document).ready(function() {
    console.log('Diagnostic: Page loaded, starting initialization');
    try {
        loadConfig();
        loadScenes();
        fetchData();
        fetchPcaStates();
        fetchRelayStates();
        setInterval(fetchData, 5000);
        startPcaStateInterval();

// Lighting slider pagination
const lightingSlider = document.querySelector('.lighting-slider');
const dots = document.querySelectorAll('.pagination-dots .dot');

// Initialize slider to first page
if (lightingSlider) {
    lightingSlider.scrollLeft = 0;
    console.log('Diagnostic: Initialized lightingSlider to scrollLeft=0');
} else {
    console.error('Diagnostic: lightingSlider not found');
    return;
}

// Update active dot
function updateActiveDot() {
    if (!lightingSlider || !dots.length) {
        console.error('Diagnostic: lightingSlider or dots missing');
        return;
    }
    const scrollPos = lightingSlider.scrollLeft;
    const pageWidth = lightingSlider.clientWidth || 1;
    const currentPage = Math.round(scrollPos / pageWidth);
    console.log(`Diagnostic: updateActiveDot - scrollPos=${scrollPos}, pageWidth=${pageWidth}, currentPage=${currentPage}`);
    dots.forEach((dot, index) => {
        dot.classList.toggle('active', index === currentPage);
    });
}

setTimeout(() => updateActiveDot(), 100);

// Dot click handler
dots.forEach(dot => {
    dot.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const page = parseInt(dot.dataset.page);
        if (isNaN(page)) {
            console.error(`Diagnostic: Invalid data-page for dot: ${dot.dataset.page}`);
            return;
        }
        console.log(`Diagnostic: Dot clicked, navigating to page ${page}`);
        const pageWidth = lightingSlider.clientWidth;
        lightingSlider.scrollTo({
            left: page * pageWidth,
            behavior: 'smooth'
        });
        setTimeout(updateActiveDot, 300);
    });
});

// Swipe and drag handling
let isDragging = false;
let startX = 0;
let scrollLeft = 0;
let velocity = 0;
let lastX = 0;
let lastTime = 0;
let animationFrame = null;
let overscrollDistance = 0;

// Snap to page
function snapToPage(targetPage, instant = false) {
    const pageWidth = lightingSlider.clientWidth || 1;
    const maxPage = dots.length - 1;
    targetPage = Math.max(0, Math.min(targetPage, maxPage));
    const targetScroll = targetPage * pageWidth;

    console.log(`Diagnostic: snapToPage called, targetPage=${targetPage}, targetScroll=${targetScroll}, overscroll=${lightingSlider.classList.contains('overscroll-start') || lightingSlider.classList.contains('overscroll-end')}`);

    if (lightingSlider.classList.contains('overscroll-start') || lightingSlider.classList.contains('overscroll-end')) {
        // Animate back from overscroll
        const startScroll = lightingSlider.scrollLeft;
        const startTransform = overscrollDistance;
        const duration = 600;
        let startTime = null;

        function animate(currentTime) {
            if (!startTime) startTime = currentTime;
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = springEase(progress);

            // Interpolate scroll position
            lightingSlider.scrollLeft = startScroll + (targetScroll - startScroll) * easedProgress;

            // Interpolate overscroll distance
            const currentTransform = startTransform * (1 - easedProgress);
            lightingSlider.style.setProperty('--overscroll-distance', `${currentTransform}px`);

            console.log(`Diagnostic: Overscroll animation, progress=${progress.toFixed(2)}, scrollLeft=${lightingSlider.scrollLeft}, --overscroll-distance=${currentTransform}px`);

            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                // Finalize position
                lightingSlider.scrollLeft = targetScroll;
                lightingSlider.style.setProperty('--overscroll-distance', '0px');
                lightingSlider.classList.remove('overscroll-start', 'overscroll-end');
                overscrollDistance = 0;
                updateActiveDot();
                lightingSlider.classList.remove('dragging');
                console.log(`Diagnostic: Overscroll animation complete, scrollLeft=${lightingSlider.scrollLeft}`);
            }
        }

        lightingSlider.classList.add('dragging');
        requestAnimationFrame(animate);
    } else {
        // Normal snap
        console.log(`Diagnostic: Snapping to page ${targetPage}, pageWidth=${pageWidth}, targetScroll=${targetScroll}, instant=${instant}`);
        lightingSlider.scrollTo({
            left: targetScroll,
            behavior: instant ? 'auto' : 'smooth'
        });
        lightingSlider.classList.remove('overscroll-start', 'overscroll-end');
        lightingSlider.style.setProperty('--overscroll-distance', '0px');
        overscrollDistance = 0;
        setTimeout(updateActiveDot, instant ? 50 : 300);
    }
}

// Calculate velocity for momentum
function calculateVelocity(currentX, currentTime) {
    const deltaX = currentX - lastX;
    const deltaTime = (currentTime - lastTime) / 1000; // Convert to seconds
    if (deltaTime > 0) {
        velocity = deltaX / deltaTime;
    }
    lastX = currentX;
    lastTime = currentTime;
}

// Momentum scrolling
function applyMomentum() {
    if (Math.abs(velocity) < 10) {
        velocity = 0;
        const pageWidth = lightingSlider.clientWidth || 1;
        snapToPage(Math.round(lightingSlider.scrollLeft / pageWidth));
        return;
    }
    lightingSlider.scrollLeft -= velocity * 0.016; // Frame time approximation (60fps)
    velocity *= 0.95; // Deceleration
    animationFrame = requestAnimationFrame(applyMomentum);
}

// Stop momentum
function stopMomentum() {
    if (animationFrame) {
        cancelAnimationFrame(animationFrame);
        animationFrame = null;
    }
    velocity = 0;
}

// Handle overscroll effect
function handleOverscroll(walk) {
    const pageWidth = lightingSlider.clientWidth || 1;
    const maxScroll = pageWidth * (dots.length - 1);
    const currentScroll = scrollLeft - walk; // Corrected scroll direction

    if (currentScroll < 0 && walk > 0) {
        // Pulling right on first page
        overscrollDistance = Math.min(walk * 0.3, pageWidth / 3);
        lightingSlider.classList.add('overscroll-start');
        lightingSlider.classList.remove('overscroll-end');
        lightingSlider.style.setProperty('--overscroll-distance', `${overscrollDistance}px`);
        lightingSlider.scrollLeft = 0;
        console.log(`Diagnostic: Overscroll start, walk=${walk}, overscrollDistance=${overscrollDistance}, --overscroll-distance=${lightingSlider.style.getPropertyValue('--overscroll-distance')}`);
        return true;
    } else if (currentScroll > maxScroll && walk < 0) {
        // Pulling left on last page
        overscrollDistance = Math.min(Math.abs(walk) * 0.3, pageWidth / 3);
        lightingSlider.classList.add('overscroll-end');
        lightingSlider.classList.remove('overscroll-start');
        lightingSlider.style.setProperty('--overscroll-distance', `${overscrollDistance}px`);
        lightingSlider.scrollLeft = maxScroll;
        console.log(`Diagnostic: Overscroll end, walk=${walk}, overscrollDistance=${overscrollDistance}, --overscroll-distance=${lightingSlider.style.getPropertyValue('--overscroll-distance')}`);
        return true;
    } else {
        // Normal scrolling
        lightingSlider.classList.remove('overscroll-start', 'overscroll-end');
        lightingSlider.style.setProperty('--overscroll-distance', '0px');
        overscrollDistance = 0;
        console.log(`Diagnostic: Normal scroll, scrollLeft=${lightingSlider.scrollLeft}`);
        return false;
    }
}

// Touch events
lightingSlider.addEventListener('touchstart', (e) => {
    if ($('#settingsModal').is(':visible')) return; // Skip if modal is open
    if (e.touches.length > 1) return;
    isDragging = true;
    stopMomentum();
    startX = e.touches[0].pageX;
    scrollLeft = lightingSlider.scrollLeft;
    lastX = startX;
    lastTime = performance.now();
    lightingSlider.classList.add('dragging');
    console.log(`Diagnostic: Touch start at X=${startX}, scrollLeft=${scrollLeft}`);
}, { passive: false });

lightingSlider.addEventListener('touchmove', (e) => {
    if ($('#settingsModal').is(':visible') || !isDragging || e.touches.length > 1) return;
    e.preventDefault();
    const x = e.touches[0].pageX;
    const walk = x - startX;
    if (!handleOverscroll(walk)) {
        lightingSlider.scrollLeft = scrollLeft - walk;
    }
    const currentTime = performance.now();
    calculateVelocity(x, currentTime);
    console.log(`Diagnostic: Touch move to X=${x}, walk=${walk}, scrollLeft=${lightingSlider.scrollLeft}, velocity=${velocity}`);
}, { passive: false });

lightingSlider.addEventListener('touchend', (e) => {
    if ($('#settingsModal').is(':visible') || !isDragging) return;
    isDragging = false;
    lightingSlider.classList.remove('dragging');
    const x = e.changedTouches[0].pageX;
    const distance = startX - x;
    const pageWidth = lightingSlider.clientWidth || 1;
    const currentPage = Math.round(lightingSlider.scrollLeft / pageWidth);
    let targetPage = currentPage;

    if (!lightingSlider.classList.contains('overscroll-start') && !lightingSlider.classList.contains('overscroll-end')) {
        if (Math.abs(distance) > pageWidth / 4 || Math.abs(velocity) > 500) {
            targetPage += distance > 0 ? 1 : -1;
        }
    }

    stopMomentum();
    snapToPage(targetPage);
    console.log(`Diagnostic: Touch end, distance=${distance}, velocity=${velocity}, targetPage=${targetPage}`);
});

// Mouse events
lightingSlider.addEventListener('mousedown', (e) => {
    if ($('#settingsModal').is(':visible')) return; // Skip if modal is open
    e.preventDefault();
    isDragging = true;
    stopMomentum();
    startX = e.pageX;
    scrollLeft = lightingSlider.scrollLeft;
    lastX = startX;
    lastTime = performance.now();
    lightingSlider.style.cursor = 'grabbing';
    lightingSlider.classList.add('dragging');
    console.log(`Diagnostic: Mouse down at X=${startX}, scrollLeft=${scrollLeft}`);
});

lightingSlider.addEventListener('mousemove', (e) => {
    if ($('#settingsModal').is(':visible') || !isDragging) return;
    e.preventDefault();
    const x = e.pageX;
    const walk = x - startX;
    if (!handleOverscroll(walk)) {
        lightingSlider.scrollLeft = scrollLeft - walk;
    }
    const currentTime = performance.now();
    calculateVelocity(x, currentTime);
    console.log(`Diagnostic: Mouse move to X=${x}, walk=${walk}, scrollLeft=${lightingSlider.scrollLeft}, velocity=${velocity}`);
});

lightingSlider.addEventListener('mouseup', (e) => {
    if ($('#settingsModal').is(':visible') || !isDragging) return;
    isDragging = false;
    lightingSlider.style.cursor = 'grab';
    lightingSlider.classList.remove('dragging');
    const x = e.pageX;
    const distance = startX - x;
    const pageWidth = lightingSlider.clientWidth || 1;
    const currentPage = Math.round(lightingSlider.scrollLeft / pageWidth);
    let targetPage = currentPage;

    if (!lightingSlider.classList.contains('overscroll-start') && !lightingSlider.classList.contains('overscroll-end')) {
        if (Math.abs(distance) > pageWidth / 4 || Math.abs(velocity) > 500) {
            targetPage += distance > 0 ? 1 : -1;
        }
    }

    stopMomentum();
    snapToPage(targetPage);
    console.log(`Diagnostic: Mouse up, distance=${distance}, velocity=${velocity}, targetPage=${targetPage}`);
});

lightingSlider.addEventListener('mouseleave', () => {
    if ($('#settingsModal').is(':visible') || !isDragging) return;
    isDragging = false;
    lightingSlider.style.cursor = 'grab';
    lightingSlider.classList.remove('dragging');
    const pageWidth = lightingSlider.clientWidth || 1;
    const currentPage = Math.round(lightingSlider.scrollLeft / pageWidth);
    stopMomentum();
    snapToPage(currentPage);
    console.log('Diagnostic: Mouse leave');
});

// Prevent overscrolling
lightingSlider.addEventListener('scroll', () => {
    const pageWidth = lightingSlider.clientWidth || 1;
    const maxScroll = pageWidth * (dots.length - 1);
    if (lightingSlider.scrollLeft < 0) {
        lightingSlider.scrollLeft = 0;
    } else if (lightingSlider.scrollLeft > maxScroll) {
        lightingSlider.scrollLeft = maxScroll;
    }
    const debouncedUpdateActiveDot = debounce(updateActiveDot, 100);
    debouncedUpdateActiveDot();
}, { passive: true });

        // Slider event listeners for lighting controls (unchanged)
        document.querySelectorAll('input[type="range"]:not(#screen-brightness)').forEach(slider => {
            const updateSlider = (value, channel) => {
                $(`#pca-value-${channel}`).text(value + '%');
                slider.style.setProperty('--value', value + '%');
                slider.value = value;
                debouncedSetBrightness('pca9685', channel, value);
            };

            let isDraggingSlider = false;

            // Mouse events
            slider.addEventListener('mousedown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                isDraggingSlider = true;
                const channel = slider.dataset.channel;
                console.log(`Diagnostic: Slider mousedown for channel ${channel}`);
                stopPcaStateInterval();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDraggingSlider) return;
                e.preventDefault();
                const channel = slider.dataset.channel;
                const rect = slider.getBoundingClientRect();
                const totalHeight = rect.height;
                const mouseY = e.clientY - rect.top;
                let value = Math.round(((totalHeight - mouseY) / totalHeight) * 100);
                value = Math.max(0, Math.min(100, value));
                console.log(`Diagnostic: Slider mousemove for channel ${channel}: ${value}%`);
                updateSlider(value, channel);
                slider.dispatchEvent(new Event('input'));
            });

            document.addEventListener('mouseup', () => {
                if (isDraggingSlider) {
                    const channel = slider.dataset.channel;
                    console.log(`Diagnostic: Slider mouseup for channel ${channel}`);
                    isDraggingSlider = false;
                    setTimeout(() => {
                        startPcaStateInterval();
                        fetchPcaStates();
                    }, 800);
                }
            });

            slider.addEventListener('input', (e) => {
                const value = parseInt(slider.value);
                const channel = slider.dataset.channel;
                console.log(`Diagnostic: Slider input for channel ${channel}: ${value}%`);
                updateSlider(value, channel);
            });

            // Touch events
            slider.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                isDraggingSlider = true;
                const channel = slider.dataset.channel;
                console.log(`Diagnostic: Slider touchstart for channel ${channel}`);
                stopPcaStateInterval();
                slider.classList.add('active');
            });

            slider.addEventListener('touchmove', (e) => {
                if (!isDraggingSlider) return;
                e.preventDefault();
                e.stopPropagation();
                const channel = slider.dataset.channel;
                const rect = slider.getBoundingClientRect();
                const totalHeight = rect.height;
                const touchY = e.touches[0].clientY - rect.top;
                let value = Math.round(((totalHeight - touchY) / totalHeight) * 100);
                value = Math.max(0, Math.min(100, value));
                console.log(`Diagnostic: Slider touchmove for channel ${channel}: ${value}%`);
                updateSlider(value, channel);
                slider.dispatchEvent(new Event('input'));
            });

            slider.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (isDraggingSlider) {
                    const channel = slider.dataset.channel;
                    console.log(`Diagnostic: Slider touchend for channel ${channel}`);
                    isDraggingSlider = false;
                    slider.classList.remove('active');
                    setTimeout(() => {
                        startPcaStateInterval();
                        fetchPcaStates();
                    }, 800);
                }
            });
        });

        $('.brightness-btn').on('click', function() {
            console.log('Diagnostic: Brightness button clicked:', $(this).data('brightness'));
            $('.brightness-btn').removeClass('active');
            $(this).addClass('active');
            const brightness = $(this).data('brightness');
            setScreenBrightness(brightness);
            debouncedSaveConfig();
        });

        // Check for obsolete slider elements
        if ($('#screen-brightness').length || $('#screen-brightness-value').length) {
            console.warn('Diagnostic: Found obsolete screen brightness slider elements');
            $('#screen-brightness, #screen-brightness-value').remove();
        }

        $('#settingsModal').on('click', function(event) {
            console.log('Diagnostic: Click on settings-modal, target:', event.target);
            if ($(event.target).is('#settingsModal')) {
                console.log('Diagnostic: Clicked on backdrop, closing modal');
                closeSettings(event);
            } else {
                console.log('Diagnostic: Clicked inside modal content, ignoring');
            }
        });

        $('.settings-content').on('click', function(event) {
            console.log('Diagnostic: Click inside settings-content, stopping propagation');
            event.stopPropagation();
        });
        // Settings toggle event listeners
        $('.settings-toggle input[type="checkbox"]').off('change').on('change', function(e) {
            e.stopPropagation(); // Prevent propagation to avoid conflicts
            const $checkbox = $(this);
            const toggle = $checkbox.parent();
            toggle.toggleClass('on', $checkbox.prop('checked'));
            console.log('Diagnostic: Toggle changed:', $checkbox.attr('id'), 'Checked:', $checkbox.prop('checked'));

            if ($checkbox.attr('id') === 'dark-mode-toggle') {
                console.log('Diagnostic: Toggling dark mode:', $checkbox.prop('checked'));
                $('body').toggleClass('dark-mode', $checkbox.prop('checked'));
                debouncedSaveConfig();
            }
            if ($checkbox.attr('id') === 'auto-theme-toggle') {
                console.log('Diagnostic: Toggling auto-theme:', $checkbox.prop('checked'));
                if ($checkbox.prop('checked')) {
                    $('#default-theme').prop('disabled', true).css('opacity', 0.5);
                    if ($('#sunrise').text() === '---' || $('#sunset').text() === '---') {
                        console.log('Diagnostic: Sunrise/sunset not available, fetching data');
                        fetchData();
                        setTimeout(() => {
                            updateThemeBasedOnTime($('#sunrise').text(), $('#sunset').text());
                        }, 1000);
                    } else {
                        updateThemeBasedOnTime($('#sunrise').text(), $('#sunset').text());
                    }
                } else {
                    $('#default-theme').prop('disabled', false).css('opacity', 1);
                    applyDefaultTheme($('#default-theme').val());
                }
                debouncedSaveConfig();
            }
        });

        $('#default-theme').off('change').on('change', function() {
            console.log('Diagnostic: Default theme changed:', $(this).val());
            if (!$('#auto-theme-toggle').prop('checked')) {
                applyDefaultTheme($(this).val());
            }
            debouncedSaveConfig();
        });

        $('.settings-toggle').off('click').on('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            const $checkbox = $(this).find('input[type="checkbox"]');
            $checkbox.prop('checked', !$checkbox.prop('checked')).trigger('change');
            console.log('Diagnostic: Settings toggle clicked:', $checkbox.attr('id'), 'New state:', $checkbox.prop('checked'));
        });
    } catch (e) {
        console.error('Diagnostic: Error in document.ready:', e);
    }
});

// Rest of your original JavaScript functions (debounce, setScreenBrightness, fetchData, etc.)
function debounce(func, wait) {
    let timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

function setScreenBrightness(brightness) {
    console.log(`Diagnostic: Setting screen brightness to ${brightness} via SSH`);
    $.ajax({
        url: '/set_screen_brightness',
        type: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({ brightness: brightness }),
        success: function(response) {
            console.log(`Diagnostic: Screen brightness set to ${brightness}:`, response);
        },
        error: function(jqXHR, textStatus, errorThrown) {
            console.error(`Diagnostic: Error setting screen brightness to ${brightness}:`, textStatus, errorThrown, 'Response:', jqXHR.responseText);
            alert('Failed to set screen brightness. Please try again.');
        }
    });
}

const debouncedSaveConfig = debounce(saveConfig, 500);

let lastSetBrightness = {};

function fetchData() {
    $.get('/get_data', function(data) {
        console.log('Diagnostic: Raw data fetched:', data);
        console.log('Diagnostic: Tank level:', data.tank_level);
        $('#sunrise').text(data.sunrise === "---" || !data.sunrise ? "---" : data.sunrise);
        $('#sunset').text(data.sunset === "---" || !data.sunset ? "---" : data.sunset);
        $('#current_datetime').text(data.current_datetime === "---" || !data.current_datetime ? "---" : data.current_datetime);
        $('#temperature').text(data.temperature !== 'Error' ? data.temperature + 'Â°C' : 'Error')
                        .toggleClass('error', data.temperature === 'Error');
        $('#battery_level').text(data.battery_level !== 'Error' ? data.battery_level : 'Error')
                          .toggleClass('error', data.battery_level === 'Error');
        $('#tank_level').text(data.tank_level !== 'Error' ? data.tank_level + '% Full' : 'Error')
                       .toggleClass('error', data.tank_level === 'Error');
        $('#storage_panel').text(data.storage_panel || 'Unknown');
        $('#rear_drawer').text(data.rear_drawer || 'Unknown');
        const gpsFix = data.gps_fix || 'No';
        const gpsSatellites = data.gps_quality.match(/\d+/) ? data.gps_quality.match(/\d+/)[0] : '0';
        const gpsDisplay = gpsFix === 'Yes' ? `${gpsSatellites} Satellites` : 'No';
        $('#gps_fix').text(gpsDisplay);
        const gpsCoords = (data.latitude && data.longitude) ? 
            `${parseFloat(data.latitude).toFixed(6)}, ${parseFloat(data.longitude).toFixed(6)}` : 'N/A';
        $('#gps-coordinates').text(gpsCoords);
    }).fail(function(jqXHR, textStatus, errorThrown) {
        console.error('Diagnostic: Error fetching /get_data:', textStatus, errorThrown);
        console.log('Diagnostic: Response text:', jqXHR.responseText);
        console.log('Diagnostic: Setting sensor values to Error due to server failure');
        $('#sunrise').text('---');
        $('#sunset').text('---');
        $('#current_datetime').text('---');
        $('#temperature').text('Error').toggleClass('error', true);
        $('#battery_level').text('Error').toggleClass('error', true);
        $('#tank_level').text('Error').toggleClass('error', true);
        $('#storage_panel').text('Unknown');
        $('#rear_drawer').text('Unknown');
        $('#gps_fix').text('No');
        $('#gps-coordinates').text('N/A');
    });
}

function fetchPcaStates() {
    $.get('/get_pca_states', function(data) {
        try {
            if (data.error === "PCA9685 not detected") {
                console.log('Diagnostic: PCA9685 not detected, disabling controls');
                $('input[id^="pca-"]').each(function() {
                    const channel = $(this).data('channel');
                    $(this).prop('disabled', true).closest('.control-item').addClass('disabled');
                    $(`#pca-value-${channel}`).text('Error').addClass('error');
                    $(`.control-item:has(input[data-channel="${channel}"]) .toggle-slider`)
                        .addClass('disabled').off('click');
                });
                $('.scene-btn').addClass('disabled').off('click');
                return;
            }
            const states = typeof data === 'string' ? JSON.parse(data) : data;
            console.log('Diagnostic: PCA states received:', states);
            Object.keys(states).forEach(channel => {
                if (['3', '9'].includes(channel)) {
                    console.log(`Diagnostic: Skipping channel ${channel}`);
                    return;
                }
                const brightness = parseInt(states[channel]) || 0;
                const valueElement = $(`#pca-value-${channel}`);
                const sliderElement = $(`#pca-${channel}`);
                const toggleSlider = $(`.control-item:has(input[data-channel="${channel}"]) .toggle-slider`);
                if (!valueElement.length || !sliderElement.length || !toggleSlider.length) {
                    console.warn(`Diagnostic: Missing elements for channel ${channel}`);
                    return;
                }
                if (lastSetBrightness[channel] && Math.abs(brightness - lastSetBrightness[channel]) > 10) {
                    console.log(`Diagnostic: Ignoring erratic update for channel ${channel}`);
                    return;
                }
                console.log(`Diagnostic: Updating channel ${channel}: brightness=${brightness}%`);
                valueElement.text(brightness + '%').removeClass('error');
                sliderElement.val(brightness).prop('disabled', false);
                sliderElement[0].style.setProperty('--value', brightness + '%');
                sliderElement.closest('.control-item').removeClass('disabled');
                if (brightness > 0) {
                    toggleSlider.addClass('on').removeClass('disabled');
                } else {
                    toggleSlider.removeClass('on').removeClass('disabled');
                }
            });
            $('.scene-btn').removeClass('disabled').each(function() {
                const scene = $(this).text().trim().toLowerCase().replace(' ', '_');
                $(this).off('click').on('click', () => activateScene(scene));
            });
            checkActiveScene();
        } catch (e) {
            console.error('Diagnostic: Error parsing /get_pca_states:', e);
        }
    }).fail(function(jqXHR, textStatus, errorThrown) {
        console.error('Diagnostic: Error fetching /get_pca_states:', textStatus, errorThrown);
        $('input[id^="pca-"]').each(function() {
            const channel = $(this).data('channel');
            $(this).prop('disabled', true).closest('.control-item').addClass('disabled');
            $(`#pca-value-${channel}`).text('Error').addClass('error');
            $(`.control-item:has(input[data-channel="${channel}"]) .toggle-slider`)
                .addClass('disabled').off('click');
        });
        $('.scene-btn').addClass('disabled').off('click');
    });
}

function fetchRelayStates() {
    $.get('/get_relay_states', function(data) {
        console.log('Diagnostic: Relay states received:', data);
        Object.keys(data).forEach(channel => {
            const state = data[channel] ? 'On' : 'Off';
            const toggleSlider = $(`#relay-value-${channel}`).closest('.control-item').find('.toggle-slider');
            $(`#relay-value-${channel}`).text(state);
            if (state === 'On') {
                toggleSlider.addClass('on');
            } else {
                toggleSlider.removeClass('on');
            }
        });
        checkActiveScene();
    }).fail(function(jqXHR, textStatus, errorThrown) {
        console.error('Diagnostic: Error fetching /get_relay_states:', textStatus, errorThrown);
    });
}

function setBrightness(type, channel, value) {
    console.log(`Diagnostic: Setting ${type} channel ${channel} to ${value}%`);
    $(`#pca-value-${channel}`).text(value + '%');
    lastSetBrightness[channel] = value;
    stopPcaStateInterval();
    $.ajax({
        url: '/set_brightness',
        type: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({ type: type, channel: channel, brightness: value }),
        success: function(response) {
            console.log(`Diagnostic: Set brightness success for channel ${channel}:`, response);
            setTimeout(() => {
                fetchPcaStates();
                startPcaStateInterval();
                checkActiveScene();
            }, 800);
        },
        error: function(jqXHR, textStatus, errorThrown) {
            console.error(`Diagnostic: Error in set_brightness for channel ${channel}:`, textStatus, errorThrown);
            setTimeout(() => {
                startPcaStateInterval();
            }, 800);
        }
    });
}

const debouncedSetBrightness = debounce(setBrightness, 100);

function toggleLight(type, channel, slider) {
    const isOn = $(slider).hasClass('on');
    const state = isOn ? 'off' : 'on';
    const value = state === 'on' ? 100 : 0;
    console.log(`Diagnostic: Toggling ${type} channel ${channel} to ${state}`);
    $(`#pca-value-${channel}`).text(value + '%');
    $(`#pca-${channel}`).val(value);
    $(`#pca-${channel}`).css('--value', value + '%');
    lastSetBrightness[channel] = value;
    if (state === 'on') {
        $(slider).addClass('on');
    } else {
        $(slider).removeClass('on');
    }
    $.ajax({
        url: '/toggle',
        type: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({ type: type, channel: channel, state: state }),
        success: function(response) {
            console.log(`Diagnostic: Toggle success for channel ${channel}:`, response);
            setTimeout(() => {
                fetchPcaStates();
                checkActiveScene();
            }, 800);
        },
        error: function(jqXHR, textStatus, errorThrown) {
            console.error(`Diagnostic: Error in toggle for channel ${channel}:`, textStatus, errorThrown);
            setTimeout(() => {
                startPcaStateInterval();
            }, 800);
        }
    });
}

function toggleRelay(type, channel, slider) {
    const isOn = $(slider).hasClass('on');
    const state = isOn ? 'off' : 'on';
    console.log(`Diagnostic: Toggling relay channel ${channel} to ${state}`);
    $(`#relay-value-${channel}`).text(state.charAt(0).toUpperCase() + state.slice(1));
    if (state === 'on') {
        $(slider).addClass('on');
    } else {
        $(slider).removeClass('on');
    }
    $.ajax({
        url: '/toggle',
        type: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({ type: type, channel: channel, state: state }),
        success: function(response) {
            console.log(`Diagnostic: Toggle success for relay ${channel}:`, response);
            fetchRelayStates();
            checkActiveScene();
        },
        error: function(jqXHR, textStatus, errorThrown) {
            console.error(`Diagnostic: Error in toggleRelay for channel ${channel}:`, textStatus, errorThrown);
        }
    });
}

function activateScene(scene) {
    console.log(`Diagnostic: Activating scene ${scene}`);
    $('.scene-btn').removeClass('active');
    currentActiveScene = null;
    checkActiveScene();
    rampFaders();
    $.ajax({
        url: '/activate_scene',
        type: 'POST',
        contentType: 'application/json',
        data: JSON.stringify({ scene: scene }),
        success: function(response) {
            console.log(`Diagnostic: Scene ${scene} activated:`, response);
            setTimeout(() => {
                fetchRelayStates();
                fetchPcaStates();
                checkActiveScene();
            }, 2100);
        },
        error: function(jqXHR, textStatus, errorThrown) {
            console.error(`Diagnostic: Error in activate_scene for ${scene}:`, textStatus, errorThrown);
            setTimeout(() => {
                fetchPcaStates();
                fetchRelayStates();
                checkActiveScene();
            }, 100);
        }
    });
}

function initiateShutdown() {
    if (confirm('Are you sure you want to shut down the control system?')) {
        console.log('Diagnostic: Initiating shutdown for both systems');
        $.ajax({
            url: '/shutdown',
            type: 'POST',
            contentType: 'application/json',
            data: JSON.stringify({ token: 'kzqWazMQIO8YrefrqwEi4cFvM9pCrlCAYG05FLpjgpc' }),
            success: function(response) {
                console.log('Diagnostic: Shutdown command sent:', response);
                alert('Both systems are shutting down. Please wait a moment before powering off.');
            },
            error: function(jqXHR, textStatus, errorThrown) {
                console.error('Diagnostic: Error initiating shutdown:', textStatus, errorThrown);
                alert('Failed to initiate shutdown. Please try again or check the server.');
            }
        });
    }
}

let pcaStateInterval;
function startPcaStateInterval() {
    if (!pcaStateInterval) {
        pcaStateInterval = setInterval(fetchPcaStates, 10000);
        console.log('Diagnostic: Started PCA state interval');
    }
}

function stopPcaStateInterval() {
    if (pcaStateInterval) {
        clearInterval(pcaStateInterval);
        pcaStateInterval = null;
        console.log('Diagnostic: Stopped PCA state interval');
    }
}

function updateThemeBasedOnTime(sunrise, sunset) {
    if (!$('#auto-theme-toggle').prop('checked')) {
        console.log('Diagnostic: Auto-theme disabled, skipping time-based theme update');
        return;
    }

    console.log('Diagnostic: Updating theme based on time:', { sunrise, sunset });
    sunrise = sunrise.replace('*', '').trim();
    sunset = sunset.replace('*', '').trim();

    let now = new Date();
    let currentTimeStr = $('#current_datetime').text().replace('*', '').trim();
    if (currentTimeStr && currentTimeStr !== '---') {
        try {
            now = new Date(currentTimeStr);
            if (isNaN(now.getTime())) {
                console.warn('Diagnostic: Invalid current time, using system time');
                now = new Date();
            }
        } catch (e) {
            console.warn('Diagnostic: Error parsing current time, using system time:', e);
        }
    }

    let sunriseTime, sunsetTime;
    const today = now.toDateString();
    if (sunrise === '---' || sunset === '---' || !sunrise || !sunset) {
        console.warn('Diagnostic: Invalid sunrise/sunset data, using Melbourne defaults (6 AM / 6 PM)');
        sunriseTime = new Date(`${today} 06:00`);
        sunsetTime = new Date(`${today} 18:00`);
    } else {
        try {
            sunriseTime = new Date(`${today} ${sunrise}`);
            sunsetTime = new Date(`${today} ${sunset}`);
            if (isNaN(sunriseTime.getTime()) || isNaN(sunsetTime.getTime())) {
                console.warn('Diagnostic: Invalid sunrise/sunset format, using Melbourne defaults');
                sunriseTime = new Date(`${today} 06:00`);
                sunsetTime = new Date(`${today} 18:00`);
            } else if (sunsetTime < sunriseTime) {
                sunsetTime.setDate(sunsetTime.getDate() + 1);
            }
        } catch (e) {
            console.error('Diagnostic: Error parsing sunrise/sunset:', e);
            sunriseTime = new Date(`${today} 06:00`);
            sunsetTime = new Date(`${today} 18:00`);
        }
    }

    console.log('Diagnostic: Applying theme - Now:', now, 'Sunrise:', sunriseTime, 'Sunset:', sunsetTime);
    const isDark = now < sunriseTime || now >= sunsetTime;
    $('body').toggleClass('dark-mode', isDark);
    $('#dark-mode-toggle').prop('checked', isDark).parent().toggleClass('on', isDark);
}

function applyDefaultTheme(theme) {
    console.log('Diagnostic: Applying default theme:', theme);
    const isDark = theme === 'dark';
    $('body').toggleClass('dark-mode', isDark);
    $('#dark-mode-toggle').prop('checked', isDark).parent().toggleClass('on', isDark);
}

function saveConfig() {
    const brightness = $('.brightness-btn.active').data('brightness') || 'medium';
    const config = {
        theme: {
            darkMode: $('#dark-mode-toggle').prop('checked') ? 'on' : 'off',
            autoTheme: $('#auto-theme-toggle').prop('checked') ? 'on' : 'off',
            defaultTheme: $('#default-theme').val(),
            screenBrightness: brightness
        }
    };
    console.log('Diagnostic: Saving config:', config);
    $.ajax({
        url: '/save_config',
        type: 'POST',
        contentType: 'application/json',
        data: JSON.stringify(config),
        success: function(response) {
            console.log('Diagnostic: Config saved successfully:', response);
            setScreenBrightness(brightness);
        },
        error: function(jqXHR, textStatus, errorThrown) {
            console.error('Diagnostic: Error saving config:', textStatus, errorThrown, 'Response:', jqXHR.responseText);
        }
    });
}

function loadConfig() {
    console.log('Diagnostic: Loading config from /load_config');
    $.get('/load_config', function(data) {
        console.log('Diagnostic: Config loaded:', data);
        try {
            if (data && data.theme) {
                const darkMode = data.theme.darkMode === 'on';
                const autoTheme = data.theme.autoTheme === 'on';
                const defaultTheme = data.theme.defaultTheme || 'light';
                let brightness = data.theme.screenBrightness || 'medium';

                // Ensure brightness is within valid range
                brightness = ['low', 'medium', 'high'].includes(brightness) ? brightness : 'medium';
                console.log(`Diagnostic: Parsed settings - darkMode: ${darkMode}, autoTheme: ${autoTheme}, defaultTheme: ${defaultTheme}, brightness: ${brightness}`);

                // Apply toggle states
                $('#dark-mode-toggle').prop('checked', darkMode).parent().toggleClass('on', darkMode);
                $('#auto-theme-toggle').prop('checked', autoTheme).parent().toggleClass('on', autoTheme);
                $('#default-theme').val(defaultTheme).prop('disabled', autoTheme).css('opacity', autoTheme ? 0.5 : 1);

                // Apply brightness button state
                $('.brightness-btn').removeClass('active');
                $(`.brightness-btn[data-brightness="${brightness}"]`).addClass('active');
                setScreenBrightness(brightness);

                // Apply theme based on autoTheme setting
                if (autoTheme) {
                    console.log('Diagnostic: Auto-theme enabled, checking sunrise/sunset');
                    if ($('#sunrise').text() !== '---' && $('#sunset').text() !== '---') {
                        updateThemeBasedOnTime($('#sunrise').text(), $('#sunset').text());
                    } else {
                        console.log('Diagnostic: Sunrise/sunset not available, fetching data');
                        fetchData();
                        setTimeout(() => {
                            updateThemeBasedOnTime($('#sunrise').text(), $('#sunset').text());
                        }, 1000);
                    }
                } else {
                    console.log('Diagnostic: Auto-theme disabled, applying default theme');
                    applyDefaultTheme(defaultTheme);
                }
            } else {
                console.warn('Diagnostic: No theme data in config, using defaults');
                applyDefaultSettings();
            }
        } catch (e) {
            console.error('Diagnostic: Error processing config data:', e);
            applyDefaultSettings();
        }
    }).fail(function(jqXHR, textStatus, errorThrown) {
        console.error('Diagnostic: Error loading config:', textStatus, errorThrown, 'Response:', jqXHR.responseText);
        applyDefaultSettings();
    });
}

let sceneConfigs = {};
let currentActiveScene = null;

function loadScenes(retryCount = 3, delay = 1000) {
    console.log('Diagnostic: Loading scenes from /get_scenes');
    $.get('/get_scenes', function(data) {
        try {
            sceneConfigs = typeof data === 'string' ? JSON.parse(data) : data;
            console.log('Diagnostic: Scenes loaded:', sceneConfigs);
            checkActiveScene();
        } catch (e) {
            console.error('Diagnostic: Error parsing /get_scenes:', e);
        }
    }).fail(function(jqXHR, textStatus, errorThrown) {
        console.error('Diagnostic: Error loading scenes:', textStatus, errorThrown);
        if (retryCount > 0) {
            console.log(`Diagnostic: Retrying loadScenes (${retryCount} attempts left)`);
            setTimeout(() => loadScenes(retryCount - 1, delay * 2), delay);
        } else {
            console.warn('Diagnostic: Failed to load scenes after retries');
        }
    });
}

const debouncedCheckActiveScene = debounce(function() {
    if (!Object.keys(sceneConfigs).length) {
        console.log('Diagnostic: Scene pages not loaded, skipping active scene check');
        return;
    }

    $.when(
        $.get('/get_pca_states'),
        $.get('/get_relay_states')
    ).done(function(pcaResponse, relayResponse) {
        try {
            const pcaStates = typeof pcaResponse[0] === 'string' ? JSON.parse(pcaResponse[0]) : pcaResponse[0];
            const relayStates = typeof relayResponse[0] === 'string' ? JSON.parse(relayResponse[0]) : relayResponse[0];
            console.log('Diagnostic: Checking active scene - PCA states:', pcaStates, 'Relay states:', relayStates);

            let isCurrentSceneValid = false;
            if (currentActiveScene && sceneConfigs[currentActiveScene]) {
                const sceneConfig = sceneConfigs[currentActiveScene];
                isCurrentSceneValid = true;

                if (sceneConfig.pca9685) {
                    Object.keys(sceneConfig.pca9685).forEach(channel => {
                        if (['3', '9'].includes(channel)) return;
                        const sceneValue = sceneConfig.pca9685[channel];
                        const currentValue = parseInt(pcaStates[channel]) || 0;
                        if (Math.abs(sceneValue - currentValue) > 2) {
                            isCurrentSceneValid = false;
                        }
                    });
                }

                if (sceneConfig.relays) {
                    Object.keys(sceneConfig.relays).forEach(channel => {
                        const sceneValue = sceneConfig.relays[channel];
                        const currentValue = relayStates[channel] ? 1 : 0;
                        if (sceneValue !== currentValue) {
                            isCurrentSceneValid = false;
                        }
                    });
                }

                if (isCurrentSceneValid) {
                    Object.keys(pcaStates).forEach(channel => {
                        if (['3', '9'].includes(channel)) return;
                        if (!sceneConfig.pca9685 || !(channel in sceneConfig.pca9685)) {
                            const currentValue = parseInt(pcaStates[channel]) || 0;
                            if (currentValue > 2) {
                                isCurrentSceneValid = false;
                            }
                        }
                    });
                    Object.keys(relayStates).forEach(channel => {
                        if (!sceneConfig.relays || !(channel in sceneConfig.relays)) {
                            const currentValue = relayStates[channel] ? 1 : 0;
                            if (currentValue !== 0) {
                                isCurrentSceneValid = false;
                            }
                        }
                    });
                }
            }

            if (!isCurrentSceneValid && currentActiveScene) {
                console.log(`Diagnostic: Current scene ${currentActiveScene} no longer valid, deactivating`);
                $('.scene-btn').removeClass('active');
                currentActiveScene = null;
            }

            if (!currentActiveScene) {
                let newActiveScene = null;
                Object.keys(sceneConfigs).forEach(scene => {
                    if (scene === currentActiveScene) return;
                    const sceneConfig = sceneConfigs[scene];
                    let isMatch = true;

                    if (sceneConfig.pca9685) {
                        Object.keys(sceneConfig.pca9685).forEach(channel => {
                            if (['3', '9'].includes(channel)) return;
                            const sceneValue = sceneConfig.pca9685[channel];
                            const currentValue = parseInt(pcaStates[channel]) || 0;
                            if (Math.abs(sceneValue - currentValue) > 2) {
                                isMatch = false;
                            }
                        });
                    }

                    if (sceneConfig.relays) {
                        Object.keys(sceneConfig.relays).forEach(channel => {
                            const sceneValue = sceneConfig.relays[channel];
                            const currentValue = relayStates[channel] ? 1 : 0;
                            if (sceneValue !== currentValue) {
                                isMatch = false;
                            }
                        });
                    }

                    if (isMatch) {
                        Object.keys(pcaStates).forEach(channel => {
                            if (['3', '9'].includes(channel)) return;
                            if (!sceneConfig.pca9685 || !(channel in sceneConfig.pca9685)) {
                                const currentValue = parseInt(pcaStates[channel]) || 0;
                                if (currentValue > 2) {
                                    isMatch = false;
                                }
                            }
                        });
                        Object.keys(relayStates).forEach(channel => {
                            if (!sceneConfig.relays || !(channel in sceneConfig.relays)) {
                                const currentValue = relayStates[channel] ? 1 : 0;
                                if (currentValue !== 0) {
                                    isMatch = false;
                                }
                            }
                        });
                    }

                    if (isMatch) {
                        newActiveScene = scene;
                    }
                });

                console.log('Diagnostic: New active scene detected:', newActiveScene);
                $('.scene-btn').removeClass('active');
                if (newActiveScene) {
                    const sceneTitle = newActiveScene.replace('_', ' ').toLowerCase();
                    $('.scene-btn').each(function() {
                        const buttonText = $(this).text().trim().toLowerCase().replace(' ', '');
                        if (buttonText.includes(sceneTitle)) {
                            $(this).addClass('active');
                        }
                    });
                    currentActiveScene = newActiveScene;
                }
            }
        } catch (e) {
            console.error('Diagnostic: Error in checkActiveScene:', e);
            $('.scene-btn').removeClass('active');
            currentActiveScene = null;
        }
    }).fail(function(jqXHR, textStatus, errorThrown) {
        console.error('Diagnostic: Error fetching states for checkActiveScene:', textStatus, errorThrown);
        $('.scene-btn').removeClass('active');
        currentActiveScene = null;
    });
}, 500);

function checkActiveScene() {
    debouncedCheckActiveScene();
}

function applyDefaultSettings() {
    console.warn('Diagnostic: Applying default settings due to config load failure');
    $('#dark-mode-toggle').prop('checked', false).parent().removeClass('on');
    $('#auto-theme-toggle').prop('checked', false).parent().removeClass('on');
    $('#default-theme').val('light').prop('disabled', false).css('opacity', 1);
    $('.brightness-btn').removeClass('active');
    $(`.brightness-btn[data-brightness="medium"]`).addClass('active');
    setScreenBrightness('medium');
    applyDefaultTheme('light');
}

function openSettings() {
    console.log('Diagnostic: Opening settings modal');
    $('#settingsModal').fadeIn();
    openTab('general');
    positionCloseButton();
    $(window).off('resize.closeButton').on('resize.closeButton', positionCloseButton);
}

function positionCloseButton() {
    const $settingsContent = $('.settings-content');
    const $closeButton = $('.close-settings');
    const contentRect = $settingsContent[0].getBoundingClientRect();
    const rem = parseFloat(getComputedStyle(document.documentElement).fontSize);
    const buttonWidth = $closeButton.outerWidth();

    const targetRight = contentRect.right + 1.5 * rem;
    const leftPosition = targetRight - buttonWidth;

    $closeButton.css({
        position: 'fixed',
        top: (contentRect.top - 1.5 * rem) + 'px',
        left: leftPosition + 'px'
    });

    console.log('Diagnostic: Positioning close button:', { contentRect, buttonWidth, targetRight, leftPosition });
}

function closeSettings(event) {
    event.stopPropagation();
    console.log('Diagnostic: Closing settings modal');
    $('#settingsModal').fadeOut();
    $(window).off('resize.closeButton');
}

function openTab(tabName) {
    console.log('Diagnostic: Opening tab:', tabName);
    $('.tab-content').removeClass('active');
    $('.tab-btn').removeClass('active');
    $('#' + tabName + '-tab').addClass('active');
    $(`[onclick="openTab('${tabName}')"]`).addClass('active');
}

function rampFaders() {
    const rampDuration = 2000;
    const stepInterval = 100;
    const steps = Math.ceil(rampDuration / stepInterval);
    let currentStep = 0;

    console.log('Diagnostic: Starting fader ramp polling');
    $('.scene-btn').removeClass('active');
    currentActiveScene = null;
    checkActiveScene();
    const interval = setInterval(() => {
        $.get('/get_pca_states', function(data) {
            try {
                const states = typeof data === 'string' ? JSON.parse(data) : data;
                console.log(`Diagnostic: Fader ramp step ${currentStep + 1}:`, states);
                Object.keys(states).forEach(channel => {
                    if (['3', '9'].includes(channel)) {
                        console.log(`Diagnostic: Skipping channel ${channel}`);
                        return;
                    }
                    const brightness = parseInt(states[channel]) || 0;
                    const valueElement = $(`#pca-value-${channel}`);
                    const sliderElement = $(`#pca-${channel}`);
                    const toggleSlider = $(`.control-item:has(input[data-channel="${channel}"]) .toggle-slider`);
                    if (!valueElement.length || !sliderElement.length || !toggleSlider.length) {
                        console.warn(`Diagnostic: Missing elements for channel ${channel}`);
                        return;
                    }
                    valueElement.text(brightness + '%');
                    sliderElement.val(brightness);
                    sliderElement[0].style.setProperty('--value', brightness + '%');
                    if (brightness > 0) {
                        toggleSlider.addClass('on');
                    } else {
                        toggleSlider.removeClass('on');
                    }
                });
                checkActiveScene();
            } catch (e) {
                console.error('Diagnostic: Error parsing /get_pca_states during ramp:', e);
            }
        }).fail(function(jqXHR, textStatus, errorThrown) {
            console.error('Diagnostic: Error fetching /get_pca_states during ramp:', textStatus, errorThrown);
        });

        currentStep++;
        if (currentStep >= steps) {
            clearInterval(interval);
            console.log('Diagnostic: Finished fader ramp polling');
            setTimeout(() => {
                fetchPcaStates();
                checkActiveScene();
            }, 100);
        }
    }, 65);
}

function refreshPage() {
    console.log('Diagnostic: Refreshing page');
    location.reload();
}
</script>
</body>
</html>